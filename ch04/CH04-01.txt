배열과 포인터 with 메모리
1️⃣ 메모리 큰 그림 (PC 기준: Code / Data / Heap / Stack)

C 프로그램 메모리는 보통 4영역으로 생각합니다.

Code(text) 영역

컴파일된 기계어(실행 코드)가 저장되는 영역

읽기 전용인 경우가 많음

Data 영역 (초기화된 전역/static)

예: int g = 10;, static int s = 3;

BSS 영역 (초기화되지 않은 전역/static)

예: int g;, static int s;

실행 시작 시 0으로 초기화됨

Heap 영역 (동적 할당)

malloc/free 로 직접 관리

위로 “커지는” 방향

Stack 영역 (함수 호출/지역 변수)

함수 호출 시 생겼다가 함수 끝나면 사라짐

아래로 “커지는” 방향

핵심

스택: 자동(함수 종료 시 자동 소멸)

힙: 수동(개발자가 free 해야 함)

지역 변수 주소를 밖으로 반환하면 위험한 이유가 “스택이 사라지기 때문”입니다.

2️⃣ 임베디드(Atmega 같은 MCU) 메모리 관점

MCU는 PC와 다르게 코드 저장 공간과 데이터 저장 공간이 물리적으로 분리되는 경우가 많습니다.

Flash (프로그램 메모리)

코드(text)가 저장

전원이 꺼져도 유지

SRAM (데이터 메모리)

실행 중 변수(스택/힙/전역 일부)가 올라감

전원 꺼지면 날아감

용량이 작아서 관리가 매우 중요

EEPROM

전원 꺼져도 유지되는 작은 저장 공간

설정값 저장 등에 사용

핵심

MCU에서는 “데이터(SRAM)가 작다”가 현실적인 제약입니다.

포인터를 이해해야 메모리(특히 SRAM)를 제대로 쓸 수 있습니다.

배열과 포인터 핵심 관계
3️⃣ “배열 이름은 포인터다”는 말의 정확한 뜻

많이 하는 말: “배열 이름은 포인터다”
정확한 표현: “배열 이름은 대부분의 표현식에서 첫 요소 주소로 변환(decay) 된다.”

즉,

arr는 배열 그 자체(타입이 배열)

하지만 대부분의 상황에서 arr는 &arr[0] 처럼 주소로 사용됩니다.

중요한 차이 (시험/실무 둘 다 중요)

arr : 첫 요소 주소처럼 사용됨 (decay)

&arr[0] : 첫 요소 주소 (진짜 포인터)

&arr : “배열 전체”의 주소 (타입이 다름)

예시(타입 느낌)

int arr[10];

arr → int* 처럼 사용됨

&arr → int (*)[10] (10개짜리 배열을 가리키는 포인터)

4️⃣ arr[i] == *(arr + i) 가 성립하는 이유 (주소 계산)

배열은 메모리에 “연속”으로 저장됩니다.

arr + i 는 주소 연산입니다.
여기서 중요한 점:

arr + 1 은 “주소 + 1바이트”가 아닙니다.

“자료형 크기만큼” 이동합니다.

예:

int 가 4바이트라면
arr + 1 은 실제로 주소가 +4 증가

그래서

arr[i] 는

내부적으로 *(arr + i) 와 동일하게 동작합니다.